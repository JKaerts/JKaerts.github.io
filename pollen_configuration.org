#+PROPERTY: header-args :tangle "./config.rkt"

Tangle this file from emacs using =C-c C-v t=.

*Note to the reader:* 

* Setup

We begin by managing all relevant imports.
 - =pollen/decode= allows for post-processing of X-expressions.
 - =pollen/tag= provides functions to work with tags.
 - =txexpr= is a library that provides a cleaner notation for X-expressions.
 - =sugar=
 - =hyphenate= will allow me to easily hyphenate in the browser.

#+BEGIN_SRC racket
  #lang racket
  (require pollen/decode
           pollen/tag
           txexpr
           sugar
           hyphenate)
#+END_SRC

Next we make sure all defined functions are exported as well

#+BEGIN_SRC racket
  (provide (all-defined-out))
#+END_SRC

Finally, we complete the setup by changing the default line break separator.
The defaut value used by =decode-paragraphs= is a single newline.
However, for debugging purposes I’d like to type every sentence on its own line in the source.
In order to still make it easy to insert a line break at an arbitrary place, I’ll use the TeX-inspired double backslash.

#+BEGIN_SRC racket
  (module setup racket/base
    (provide (all-defined-out))
    (define linebreak-separator "\\\\"))
#+END_SRC

* Setting up hyphenation

The setup for hyphenation in the browser closely follows the example given in the Pollen documentation.
We begin by declaring an attribute (which we can attach to a tag) that specifies this tag doesn’t need to be hyphenated.

#+BEGIN_SRC racket
  (define no-hyphens-attr '(hyphens "none"))
#+END_SRC

Now we get to the meat of the matter.
The following code defines a function that hyphenates a block of text.
It does this by a call to the function =hyphenate=.
The keyword arguments ensure that after a hyphen is inserted, there are at least three characters left at both sides of the hyphen.
Some types of tagged X-expressions are omitted from hyphenation.
These are the ones satisfying one of two conditions:
 - Either the tag is of a type which we do not want to have hyphenation such as headings, style tags, script tags and sections of mathematics.
   This last one is not part of the default example in the docs but without it, TeX commands like =\mapsto= get hyphenated to =\maps-to= and this hinders proper display of the symbols.
 - Either the tag has the attribute (defined above) which prohibits hyphentaion.

#+BEGIN_SRC racket
  (define (hyphenate-block block-tx)
    (define (no-hyphens? tx)
      (or (member (get-tag tx) '(th h1 h2 h3 h4 style script mathjax))
          (member no-hyphens-attr (get-attrs tx))))
    (hyphenate block-tx
               #:min-left-length 3
               #:min-right-length 3
               #:omit-txexpr no-hyphens?))
#+END_SRC

* Tag functions

** Mathematics

Using MathJax for the typesetting of math in the browser, we define two shorthand tag functions, the first for inline math and the second for displayed math.

#+BEGIN_SRC racket
  (define ($ . elements)
    `(mathjax ,(apply string-append `("$" ,@elements "$"))))
  (define ($$ . elements)
    `(mathjax ,(apply string-append `("$$" ,@elements "$$"))))
#+END_SRC

** Headings

Headings are defined using a macro (inspired by the example project ‘Typography for Lawyers’).
The macro takes a name and a tag and uses these to define a heading.
The name of the heading type is also included in the =class= attribute to allow precision styling of each type.

#+BEGIN_SRC racket
  (define-syntax-rule (define-heading heading-name tag)
    (define heading-name
      (default-tag-function tag
        #:class (symbol->string 'heading-name))))
#+END_SRC

In this project I use two types of headings at the moment.

#+BEGIN_SRC racket
  (define-heading topic 'h3)
  (define-heading heading 'h4)
#+END_SRC

** Lists

List types are defined like in the example project ’Typography for Lawyers’.
A detailed explanation is yet to come as I dissect this code

#+BEGIN_SRC racket
  (define (detect-list-items elems)
    (define elems-merged (merge-newlines elems))
    (define (list-item-break? elem)
      (define list-item-separator-pattern (regexp "\n\n\n+"))
      (and (string? elem) (regexp-match list-item-separator-pattern elem)))
    (define list-of-li-elems (filter-split elems-merged list-item-break?))
    (define list-of-li-paragraphs
      (map (λ(li) (decode-paragraphs li #:force? #t)) list-of-li-elems))
    (define li-tag (default-tag-function 'li))
    (map (λ(lip) (apply li-tag lip)) list-of-li-paragraphs))

  (define (make-list-function tag [attrs empty])
    (λ args (list* tag attrs (detect-list-items args))))

  (define bullet-list (make-list-function 'ul))
  (define numbered-list (make-list-function 'ol))
#+END_SRC

** Theorems

In order to display theorems and like-minded structures in the text, I took inspiration from the =\proclaim= macro from plain TeX.
A theorem consists of two parts: the title and the body.
In order to get the wanted results from paragraph detection further on, I need to enclose all of the theorem in a =div= tag.
This div-tag will have as its class attribute the name of the theorem type (just like with headings) followed by =-body=, which allows me to style the theorem body.
The theorem title is a =span= tag with a class attribute consisting of the theorem type and =-title=.

#+BEGIN_SRC racket
  (define-syntax-rule (define-theorem theorem-name)
    (define (theorem-name title . elements)
      `(div ((class ,(string-append (symbol->string 'theorem-name) "-body")))
            (span ((class ,(string-append (symbol->string 'theorem-name) "-title"))) ,title)
            " "
            ,@elements)))
#+END_SRC

At the moment I only use one type of theorem

#+BEGIN_SRC racket
  (define-theorem theorem)
#+END_SRC

** Exposition

I’m experimenting with tooltips for gradual exposition.
This code is a prototype.
A more detailed explanation is still to come.

#+BEGIN_SRC racket
  (define (exposition . elements)
    `(span ((class "tooltip")
            (onclick "this.classList.toggle('tooltip_visible')"))
           "+"
           (span ((class "tooltip-inner"))
                 (span ((class "no-hyphens"))
                       ,@elements))))
#+END_SRC

** Root tag

Finally we process the root tag.
This function needs to be cleaned up.
A more detailed explanation is still to come.

#+BEGIN_SRC racket
  (define (root . elements)
    (define elements-with-paragraphs
      (decode-elements elements #:txexpr-elements-proc decode-paragraphs #:exclude-attrs '((class "therorem"))))
    (list* 'div '((id "doc"))
           (decode-elements elements-with-paragraphs
                            #:block-txexpr-proc hyphenate-block
                            #:exclude-tags '(style script))))
#+END_SRC
